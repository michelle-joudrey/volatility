# Volatility
# Copyright (c) 2010, 2011, 2012 Michael Ligh <michael.ligh@mnin.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details. 
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
#

import volatility.utils as utils
import volatility.obj as obj
import volatility.commands as commands
import volatility.win32.modules as modules
import volatility.win32.tasks as tasks 
import volatility.debug as debug

#--------------------------------------------------------------------------------
# constants 
#--------------------------------------------------------------------------------

GDT_DESCRIPTORS = dict(enumerate([
    "Data RO",
    "Data RO Ac", 
    "Data RW", 
    "Data RW Ac",
    "Data RO E",
    "Data RO EA",
    "Data RW E",
    "Data RW EA",
    "Code EO", 
    "Code EO Ac",
    "Code RE", 
    "Code RE Ac",
    "Code EO C",
    "Code EO CA",
    "Code RE C",
    "Code RE CA",
    "<Reserved>",
    "TSS16 Avl",
    "LDT",
    "TSS16 Busy",
    "CallGate16",
    "TaskGate",
    "Int Gate16",
    "TrapGate16",
    "<Reserved>",
    "TSS32 Avl",
    "<Reserved>",
    "TSS32 Busy",
    "CallGate32",
    "<Reserved>",
    "Int Gate32",
    "TrapGate32",
]))

#--------------------------------------------------------------------------------
# object classes  
#--------------------------------------------------------------------------------

class _KPCROnx86(obj.CType):

    def idt_entries(self):
        for i, entry in enumerate(self.IDT.dereference()):
            yield i, entry      

    def gdt_entries(self):
        for i, entry in enumerate(self.GDT.dereference()):
            yield i, entry   

class _KIDTENTRY(obj.CType):
    """Class for interrupt descriptors"""

    @property
    def Address(self):
        """Return the address of the IDT entry handler"""

        if self.ExtendedOffset == 0:
            return 0

        return (self.ExtendedOffset.v() << 16 | self.Offset.v())

class _KGDTENTRY(obj.CType):
    """A class for GDT entries"""

    @property
    def Type(self):
        """Get a string name of the descriptor type"""

        flag = self.HighWord.Bits.Type.v() & 1 << 4
        type = self.HighWord.Bits.Type.v() & ~(1 << 4)

        if flag == 0:
            type += 16

        return GDT_DESCRIPTORS.get(type, "UNKNOWN")

    @property
    def Base(self):
        """Get the base (start) of memory for this GDT"""
        return (self.BaseLow + ((self.HighWord.Bits.BaseMid + 
               (self.HighWord.Bits.BaseHi << 8)) << 16))

    @property
    def Limit(self):
        """Get the limit (end) of memory for this GDT"""
        limit = (self.HighWord.Bits.LimitHi.v() << 16) | self.LimitLow.v()

        if self.HighWord.Bits.Granularity == 1:
            limit = (limit + 1) * 0x1000
            limit -= 1

        return limit 

    @property
    def CallGate(self):
        """Get the call gate address"""
        return ((self.HighWord.v() & 0x0000ffff) << 16) | self.LimitLow.v()

    @property
    def Present(self):
        """Returns True if the entry is present"""
        return self.HighWord.Bits.Pres == 1

    @property
    def Granularity(self):
        """Returns True if page granularity is used. Otherwise
        returns False indicating byte granularity is used."""
        return self.HighWord.Bits.Granularity == 1

    @property
    def Dpl(self):
        """Returns the descriptor privilege level"""
        return self.HighWord.Bits.Dpl

#--------------------------------------------------------------------------------
# profile modifications 
#--------------------------------------------------------------------------------

class MalwareIDTGDTx86(obj.ProfileModification):
    before = ['WindowsObjectClasses', 'WindowsOverlay']
    conditions = {'os': lambda x: x == 'windows',
                  'memory_model': lambda x: x == '32bit'}
    def modification(self, profile):
        profile.object_classes.update({
            '_KIDTENTRY': _KIDTENTRY,
            '_KGDTENTRY': _KGDTENTRY,
            '_KPCR': _KPCROnx86,
        })
        profile.merge_overlay({"_KPCR" : [None, 
            {'IDT': [None, 
                    ["pointer", ["array", 256, ['_KIDTENTRY']]]], 
            }]}) 
        # Since the real GDT size is read from a register, we'll just assume
        # that there are 128 entries (which is normal for most OS)
        profile.merge_overlay({"_KPCR" : [None, 
            {'GDT': [None, 
                    ["pointer", ["array", 128, ['_KGDTENTRY']]]], 
            }]}) 

#--------------------------------------------------------------------------------
# GDT plugin 
#--------------------------------------------------------------------------------

class GDT(commands.Command):
    "Display Global Descriptor Table"

    def calculate(self):
        addr_space = utils.load_as(self._config)

        # Currently we only support x86. The x64 does still have a GDT 
        # but hooking is prohibited and results in bugcheck. 
        if addr_space.profile.metadata.get("memory_model", "32bit") != "32bit":
            debug.error("This plugin only supports x86")

        # Find the KPCR. If there are multiple CPUs (and thus multiple 
        # GDTs), use kpcrscan and pass the address of each KPCR to this
        # plugin using the --kpcr parameter. 
        volmagic = obj.Object('VOLATILITY_MAGIC', 0x0, addr_space)
        kpcr = obj.Object("_KPCR", offset = volmagic.KPCR.v(), vm = addr_space)

        for i, entry in kpcr.gdt_entries():
            yield i, entry

    def render_text(self, outfd, data):

        outfd.write("{0:<6} {1:<24} {2:<12} {3:<14} {4:<6} {5:6} {6:6}\n".format(
            "Sel", "Base", "Limit", "Type", "DPL", "Gr", "Pr", "Flag"))

        for n, entry in data:

            selector = n * 8

            # Is the entry present? This applies to all types of GDT entries
            if entry.Present:
                present = "P" 
            else:
                present = "Np"

            # The base, limit, and granularity is calculated differently
            # for 32bit call gates than they are for all other types. 
            if entry.Type == 'CallGate32':
                base = entry.CallGate
                limit = '-'
                granularity = '-'
            else:
                base = entry.Base
                limit = hex(entry.Limit)
                if entry.Granularity:
                    granularity = "Pg"
                else:
                    granularity = "By"

            outfd.write("{0:<#6x} {1:<#24x} {2:<12} {3:<14} {4:<6} {5:<6} {6:6}\n".format(
                selector, base, limit, entry.Type, entry.Dpl, granularity, present))

#--------------------------------------------------------------------------------
# IDT plugin 
#--------------------------------------------------------------------------------

class IDT(commands.Command):
    "Display Interrupt Descriptor Table"

    def calculate(self):
        addr_space = utils.load_as(self._config)

        # Currently we only support x86. The x64 does still have a IDT 
        # but hooking is prohibited and results in bugcheck. 
        if addr_space.profile.metadata.get("memory_model", "32bit") != "32bit":
            debug.error("This plugin only supports x86")

        # Find the KPCR. If there are multiple CPUs (and thus multiple 
        # GDTs), use kpcrscan and pass the address of each KPCR to this
        # plugin using the --kpcr parameter. 
        volmagic = obj.Object('VOLATILITY_MAGIC', 0x0, addr_space)
        kpcr = obj.Object("_KPCR", offset = volmagic.KPCR.v(), vm = addr_space)

        mods = dict((mod.DllBase, mod) for mod in modules.lsmod(addr_space))
        mod_addrs = sorted(mods.keys())

        # Get the GDT for access to selector bases
        gdt = dict((i*8, sd.Base) for i, sd in GDT(self._config).calculate())

        for i, entry in kpcr.idt_entries():
            # Where the IDT entry points. Per MITRE, add the GDT selector 
            # base if available. This allows us to detect sneaky attempts 
            # to hook IDT entries by changing the entry's GDT selector. 
            addr = entry.Address + gdt.get(entry.Selector.v(), 0)

            # Lookup the function's owner 
            module = tasks.find_module(mods, mod_addrs, addr)

            yield i, entry, addr, module

    def render_text(self, outfd, data):
        outfd.write("{0:<8} {1:<8} {2:<24} {3}\n".format(
            "Index", "Selector", "Value", "Details"))

        for n, entry, addr, module in data:

            if module:
                module_name = str(module.BaseDllName or '')    
            else:
                module_name = "UNKNOWN"

            outfd.write("{0:<8X} {1:<8X} {2:<#24x} {3}\n".format(
                n, entry.Selector, entry.Address, module_name))
