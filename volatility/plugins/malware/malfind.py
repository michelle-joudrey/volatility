# Volatility
# Copyright (c) 2010, 2011, 2012 Michael Ligh <michael.ligh@mnin.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details. 
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
#

import os 
import volatility.utils as utils 
import volatility.obj as obj
import volatility.debug as debug
import volatility.win32.tasks as tasks
import volatility.win32.modules as modules
import volatility.plugins.taskmods as taskmods
import volatility.plugins.vadinfo as vadinfo
import volatility.plugins.overlays.windows.windows as windows
import volatility.plugins.overlays.windows.win2003 as win2003

try:
    import yara 
    has_yara = True
except ImportError:
    has_yara = False

try:
    import distorm3
    has_distorm3 = True
except ImportError:
    has_distorm3 = False

#--------------------------------------------------------------------------------
# object classes 
#--------------------------------------------------------------------------------

class MalwareEPROCESS(windows._EPROCESS):
    """Extension of the default EPROCESS with some helpers"""

    def session_id(self):
        """Returns the Session ID of the process"""

        if self.Session.is_valid():
            process_space = self.get_process_address_space()
            if process_space:
                return obj.Object("_MM_SESSION_SPACE", 
                                  offset = self.Session, 
                                  vm = process_space).SessionId

        return obj.NoneObject("Cannot find process session") 

    def search_process_memory(self, s, filter = None):
        """Search memory for a simple byte string.

        @param s: the string to search for 
        @param filter: a callable (can be lambda) 
            that applies a fitler to the MMVAD and returns 
            True if the vad should be searched, or false 
            otherwise. For example, to only search 
            private memory segments you can use the following:
            filter=lambda x: x.u.VadFlags.PrivateMemory == 1.
            If filter is not supplied, all vads are searched. 
        """

        for vad in self.get_vads():
            if vad == None:
                continue 
            if filter:
                if not filter(vad):
                    continue
            # Get the memory contents 
            data = vad.get_data()
            # Track our position through the buffer 
            offset = 0
            while 1:
                next_offset = data[offset:].find(s)
                if next_offset == -1:
                    break
                address = vad.get_start() + offset + next_offset 
                yield address 
                offset += next_offset + len(s)

    def find_injections(self):
        """
        Find injected code.

        This looks for private allocations that are committed, 
        memory-resident, non-empty (not all zeros) and with an 
        original protection that includes execute rights. 

        It is important to note that protections are applied at 
        the allocation granularity (page level). Thus the original
        protection might not be the current protection, and it
        also might not apply to all pages in the VAD range. 
        """

        for vad in self.get_vads():
            if vad == None:
                continue
            # Memory must be private 
            if vad.u.VadFlags.PrivateMemory == 0:
                continue 
            protect_str = vadinfo.PROTECT_FLAGS.get(vad.u.VadFlags.Protection.v(), "")
            # Memory must be writable and executable 
            if not "EXECUTE" in protect_str or not "WRITE" in protect_str:
                continue
            # The private memory check above will usually ensure 
            # we've found a short vad, but not always
            if vad.Tag != "VadS":
                continue 
            data = vad.get_data()
            # Skip empty segments 
            if data.count(chr(0)) == len(data):
                continue
            yield vad, data

    def list_mapped_files(self, exe_only = True):
        """
        Generator for mapped files in process memory. 

        @param exe_only: only find files that appear
            to be executables by checking the first two
            bytes are MZ. 
        """
        
        process_space = self.get_process_address_space()

        for vad in self.get_vads():
            if vad == None:
                continue
            # Move on if there's no _FILE_OBJECT 
            try:
                file_obj = vad.get_file_object()
            except AttributeError:
                continue 
            # Move on if the memory isn't executable. This ignores
            # mapped files like fonts and other data files. 
            if not exe_only or process_space.zread(vad.get_start(), 2) == "MZ":
                yield vad, file_obj.FileName

class _EPROCESSwin2003(MalwareEPROCESS, win2003._EPROCESS):
   """A class that inherits from both the Malware EPROCESS
    and the Windows 2003 EPROCESS such that the result is a
    class that contains the malware methods and works on all
    systems including and after 2003."""

   pass

#--------------------------------------------------------------------------------
# profile modifications  
#--------------------------------------------------------------------------------

class MalwareObjectClasesXP(obj.ProfileModification):
    before = ['WindowsObjectClasses']
    conditions = {'os': lambda x: x == 'windows', 
                  'major': lambda x: x == 5, 
                  'minor': lambda x: x <= 2}
    def modification(self, profile):
        profile.object_classes.update({
            '_EPROCESS': MalwareEPROCESS, 
        })

class MalwareObjectClases2003(obj.ProfileModification):
    before = ['WindowsObjectClasses', 'Win2003MMVad']

    def check(self, profile):
        m = profile.metadata
        return (m.get('os', None) == 'windows' and
                (m.get('major') > 5 or (m.get('major') == 5 and m.get('minor') >= 2)))

    def modification(self, profile):
        profile.object_classes.update({
           '_EPROCESS': _EPROCESSwin2003,
       })

#--------------------------------------------------------------------------------
# functions 
#--------------------------------------------------------------------------------

def Disassemble(data, start, bits = '32bit', stoponret = False):
    """Dissassemble code with distorm3. 

    @param data: python byte str to decode
    @param start: address where `data` is found in memory
    @param bits: use 32bit or 64bit decoding 
    @param stoponret: stop disasm when function end is reached
    
    @returns: tuple of (offset, instruction, hex bytes)
    """

    if not has_distorm3:
        raise StopIteration

    if bits == '32bit':
        mode = distorm3.Decode32Bits
    else:   
        mode = distorm3.Decode64Bits

    for o, _, i, h in distorm3.DecodeGenerator(start, data, mode):
        if stoponret and i.startswith("RET"):
            raise StopIteration
        yield o, i, h 

#--------------------------------------------------------------------------------
# yarascan
#--------------------------------------------------------------------------------

class YaraScan(taskmods.DllList):
    "Scan process or kernel memory with Yara signatures"

    def __init__(self, config, *args, **kwargs):
        taskmods.DllList.__init__(self, config, *args, **kwargs)
        config.add_option("KERNEL", short_option='K', default=False, action='store_true', 
                        help='Scan kernel modules')
        config.add_option("WIDE", short_option='W', default=False, action='store_true', 
                        help='Match wide (unicode) strings')
        config.add_option('YARA-RULES', short_option='Y', default=None,
                        help='Yara rules (as a string)')
        config.add_option('YARA-FILE', short_option='y', default=None,
                        help='Yara rules (rules file)')
        config.add_option('DUMP-DIR', short_option='D', default=None,
                        help='Directory in which to dump the files')

    def calculate(self):

        if not has_yara:
            debug.error("Please install Yara from code.google.com/p/yara-project")

        addr_space = utils.load_as(self._config)

        if self._config.YARA_RULES:
            s = self._config.YARA_RULES
            # Don't wrap hex or regex rules in quotes 
            if s[0] not in ("{", "/"): s = '"' + s + '"'
            # Scan for unicode strings 
            if self._config.WIDE: s += "wide"
            rules = yara.compile(sources={
                        'n' : 'rule r1 {strings: $a = ' + s + ' condition: $a}'
                        })
        elif self._config.YARA_FILE:
            rules = yara.compile(self._config.YARA_FILE)
        else:
            debug.error("You must specify a string (-Y) or a rules file (-y)")

        if self._config.KERNEL:
                
            # Find KDBG so we know where kernel memory begins. Do not assume
            # the starting range is 0x80000000 because we may be dealing with
            # an image with the /3GB boot switch. 
            kdbg = tasks.get_kdbg(addr_space)
            start = kdbg.MmSystemRangeStart.dereference_as("address")

            ## What's a better way to determine the end?
            if addr_space.profile.metadata.get('memory_model', '32bit') == '32bit':
                stop = 0xFFFFFFFF
            else:
                stop = 0xFFFFFFFFFFFFFFFF

            # Size of chunks to read as we brute force through the AS
            chunksize = 0x100000 # 1 MB

            # Modules so we can map addresses to owners
            mods = dict((mod.DllBase, mod) 
                        for mod in modules.lsmod(addr_space))
            mod_addrs = sorted(mods.keys())

            # There are multiple views (GUI sessions) of kernel memory.
            # Since we're scanning virtual memory and not physical, 
            # all sessions must be scanned for full coverage. This 
            # really only has a positive effect if the data you're
            # searching for is in GUI memory. 
            sessions = [] 

            for proc in tasks.pslist(addr_space):
                sid = proc.session_id()
                # Skip sessions we've already seen 
                if sid == None or sid in sessions:
                    continue 
                session_space = proc.get_process_address_space()
                if session_space == None:
                    continue 
                sessions.append(sid)
                for addr in xrange(0, stop - start, chunksize):
                    data = session_space.zread(start + addr, chunksize)
                    # Skip chunks that are all zero - saves time 
                    if data.count(chr(0)) == len(data):
                        continue
                    for hit in rules.match(data = data):
                        for (offset, _, _) in hit.strings:
                            address = start + addr + offset 
                            module = tasks.find_module(mods, mod_addrs, address)
                            yield module, address, hit, data[offset:]
        else:
            for task in self.filter_tasks(tasks.pslist(addr_space)):
                for vad in task.get_vads():
                    if vad == None:
                        continue 
                    data = vad.get_data()
                    # Skip chunks that are all zero - saves time 
                    if data.count(chr(0)) == len(data):
                        continue
                    for hit in rules.match(data = data):
                        for (offset, _, _) in hit.strings:
                            address = vad.get_start() + offset
                            yield task, address, hit, data[offset:]

    def render_text(self, outfd, data):
        
        for o, addr, hit, content in data:
            outfd.write("Rule: {0}\n".format(hit.rule))

            # Find out if the hit is from user or kernel mode 
            if o == None:
                outfd.write("Owner: (Unknown Kernel Memory)\n")
                filename = "kernel.{0:#x}.dmp".format(addr)
            elif o.obj_name == "_EPROCESS":
                outfd.write("Owner: Process {0} Pid {1}\n".format(o.ImageFileName, 
                    o.UniqueProcessId))
                filename = "process.{0:#x}.{1:#x}.dmp".format(o.obj_offset, addr)
            else:   
                outfd.write("Owner: {0}\n".format(o.BaseDllName))
                filename = "kernel.{0:#x}.{1:#x}.dmp".format(o.obj_offset, addr)

            # Dump the data if --dump-dir was supplied
            if self._config.DUMP_DIR:
                path = os.path.join(self._config.DUMP_DIR, filename)
                fh = open(path, "wb")
                fh.write(content)
                fh.close()

            outfd.write("".join(
                ["{0:#010x}  {1:<48}  {2}\n".format(addr + o, h, ''.join(c)) 
                for o, h, c in utils.Hexdump(content[0:64])
                ]))

#--------------------------------------------------------------------------------
# malfind
#--------------------------------------------------------------------------------

class Malfind(taskmods.DllList):
    "Find hidden and injected code"

    def render_text(self, outfd, data):
        for task in data:
            for vad, content in task.find_injections():

                outfd.write("Process: {0} Pid: {1} Address: {2:#x}\n".format(
                    task.ImageFileName, task.UniqueProcessId, vad.get_start()))

                outfd.write("Vad Tag: {0} Protection: {1}\n".format(
                    vad.Tag, vadinfo.PROTECT_FLAGS.get(vad.u.VadFlags.Protection.v(), "")))

                outfd.write("Flags: {0}\n".format(str(vad.u.VadFlags)))
                outfd.write("\n")

                outfd.write("{0}\n".format("\n".join(
                    ["{0:#010x}  {1:<48}  {2}".format(vad.get_start(), h, ''.join(c)) 
                    for o, h, c in utils.Hexdump(content[0:64])
                    ])))

                outfd.write("\n")
                outfd.write("\n".join(
                    ["{0:#x} {1:<16} {2}".format(o, h, i) 
                    for o, i, h in Disassemble(content[0:64], vad.get_start())
                    ]))

                outfd.write("\n\n") 

#--------------------------------------------------------------------------------
# ldrmodules 
#--------------------------------------------------------------------------------

class LdrModules(taskmods.DllList):
    "Detect unlinked DLLs"

    def render_text(self, outfd, data):

        outfd.write("{0:<8} {1:<20} {2:<12} {3:<8} {4:<8} {5:<8} {6}\n".format(
            'Pid', 'Process', 'Base', 'InLoad', 'InInit', 'InMem', 'MappedPath'))

        for task in data:
            # Build a dictionary for all three PEB lists where the
            # keys are base address and module objects are the values
            inloadorder = dict((mod.DllBase.v(), mod) 
                                for mod in task.get_load_modules())
            ininitorder = dict((mod.DllBase.v(), mod) 
                                for mod in task.get_init_modules())
            inmemorder  = dict((mod.DllBase.v(), mod) 
                                for mod in task.get_mem_modules())
            # Build a similar dictionary for the mapped files 
            mapped_files = dict((vad.get_start(), name) 
                                for vad, name in task.list_mapped_files())
            # For each base address with a mapped file, print info on 
            # the other PEB lists to spot discrepancies. 
            for base in mapped_files.keys():
                # Does the base address exist in the PEB DLL lists?
                load_mod = inloadorder.get(base, None)
                init_mod = ininitorder.get(base, None)
                mem_mod = inmemorder.get(base, None)
                # Report if the mapped files are in the PEB lists 
                outfd.write("{0:<8} {1:<20} {2:<#12x} {3:<8} {4:<8} {5:<8} {6}\n".format(
                        task.UniqueProcessId, 
                        task.ImageFileName, 
                        base, 
                        load_mod != None, 
                        init_mod != None, 
                        mem_mod != None, 
                        mapped_files[base])
                        )
                # Print the full paths and base names in verbose mode 
                if self._config.verbose:
                    if load_mod:
                        outfd.write("  Load Path: {0} : {1}\n".format(load_mod.FullDllName, load_mod.BaseDllName))
                    if init_mod:
                        outfd.write("  Init Path: {0} : {1}\n".format(init_mod.FullDllName, init_mod.BaseDllName))
                    if mem_mod: 
                        outfd.write("  Mem Path:  {0} : {1}\n".format(mem_mod.FullDllName, mem_mod.BaseDllName)) 
        
    

            